/*
###Задание 1
Необходимо создать класс Library. Конструктор класса, должен принимать начальный 
список книг (массив) в качестве аргумента. Убедитесь, что предоставленный массив 
не содержит дубликатов; в противном случае необходимо выбросить ошибку.
1. Класс должен содержать приватное свойство #books, которое должно хранить 
книги, переданные при создании объекта.
2. Реализуйте геттер-функцию allBooks, которая возвращает текущий список книг.
3. Реализуйте метод addBook(title), который позволяет добавлять книгу в список. 
Если книга с таким названием уже существует в списке, выбросьте ошибку с 
соответствующим сообщением.
4. Реализуйте метод removeBook(title), который позволит удалять книгу из списка 
по названию. Если книги с таким названием нет в списке, выбросьте ошибку с 
соответствующим сообщением.
5. Реализуйте метод hasBook(title), который будет проверять наличие книги в 
библиотеке и возвращать true или false в зависимости от того, есть ли такая 
книга в списке или нет.
*/






class Library {
  #books = [];

  constructor(books) {
    // Проверка наличия дубликатов в начальном списке книг
    if (new Set(books).size !== books.length) {
      throw new Error("There are duplicate books in the array!");
    }

    this.#books = books;
  }
  // Геттер-функция для получения текущего списка книг
  get books() {
    return this.#books;
  }

  get allBooks() {
    return this.books;
  }

  get allBooksJson() {
    return JSON.stringify(this.books, null, 2);
  }

  addBook(title) {
    if (this.#books.includes(title)) {
      throw new Error(`Книга с названием "${title}" уже существует в списке.`);
    }
    this.#books.push(title);
  }

  removeBook(title) {
    const index = this.#books.indexOf(title);
    if (index !== -1) {
      this.#books.splice(index, 1);
    } else {
      throw new Error(`Книги с названием "${title}" нет в списке.`);
    }
  }
}

const books = ["peaceful warrior ", "Rich", "faiting club", "Rich Son"]; 
const newBooks = new Library(books);

console.log(newBooks);
console.log(newBooks.allBooks);
console.log(newBooks.allBooksJson);
console.log(newBooks.addBook("Grinch"));


newBooks.addBook("memoris of a stock speculator");
console.log(newBooks.allBooks);
console.log(newBooks.allBooksJson);
console.log(newBooks.removeBook("Rich"));
console.log(newBooks.allBooks);


console.log(books.indexOf("Grinch"));






// new Set(arrayBook): Здесь создается новый объект типа Set на основе переданного массива arrayBook. Объект Set представляет собой коллекцию уникальных значений, то есть в нем не может быть дубликатов.

// .size: Это свойство объекта Set, которое возвращает количество уникальных элементов в нем.

// !== arrayBook.length: Здесь сравнивается количество уникальных элементов в Set с общим количеством элементов в исходном массиве arrayBook. Если эти значения не совпадают, то это означает, что в исходном массиве были дубликаты.

// Эта строчка кода определяет геттер-функцию с именем allBooks внутри класса Library. Давайте подробно разберем, что происходит:

// javascript
// Copy code
// // Геттер-функция для получения текущего списка книг
// get allBooks() {
//   return this.#books;
// }
// get allBooks(): Это объявление геттер-функции с именем allBooks. Геттер-функции используются для получения значения свойства объекта. Они предоставляют доступ к свойству, но выглядят как обычные свойства.

// { return this.#books; }: Внутри тела геттер-функции указан код, который будет выполнен, когда происходит обращение к свойству allBooks. В данном случае геттер просто возвращает значение приватного свойства #books текущего экземпляра объекта.

// this.#books: Обращение к приватному свойству #books, которое содержит список книг, переданных при создании объекта класса Library.
// Таким образом, при обращении к allBooks, будет возвращено значение приватного свойства #books, предоставляя доступ к текущему списку книг. Например, если у вас есть экземпляр library класса Library, вы можете получить текущий список книг, написав library.allBooks.


// if (this.#books.includes(title)): Эта строка проверяет, содержится ли переданное название книги в массиве this.#books. this.#books предположительно является приватным массивом (по обозначению # перед именем), который хранит список уже добавленных книг.
// throw new Error(Книга с названием "${title}" уже существует в списке.);: Если название книги уже присутствует в массиве, то выбрасывается исключение типа Error с сообщением, указывающим, что книга с таким названием уже существует в списке.

// this.#books.push(title);: Если название книги не найдено в массиве, то оно добавляется в конец массива this.#books с использованием метода push.


// const index = this.#books.indexOf(title);: Здесь создается переменная index, в которую записывается индекс элемента с указанным названием title в массиве this.#books. Метод indexOf используется для поиска индекса элемента в массиве.

// if (index !== -1) {: Эта строка проверяет, был ли найден элемент с указанным названием в массиве. Если index не равен -1, значит, элемент найден.

// this.#books.splice(index, 1);: Если элемент был найден, то используется метод splice для удаления одного элемента из массива. В данном случае, удаляется элемент с индексом index. Таким образом, книга с указанным названием удаляется из списка.

// else { throw new Error(Книги с названием "${title}" нет в списке.); }: Если элемент с указанным названием не был найден (то есть index === -1), выбрасывается исключение типа Error с сообщением, указывающим, что книги с таким названием нет в списке.